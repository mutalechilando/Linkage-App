"use strict";

var _requestContentType = require("./requestContentType");

describe('requestContentType', () => {
  it('returns "application/json" for a normal resource', () => {
    expect((0, _requestContentType.requestContentType)('create', {
      resource: 'test',
      data: 'test'
    })).toBe('application/json');
  });
  it('returns "application/json-patch+json" when the fetch type is "json-patch"', () => {
    expect((0, _requestContentType.requestContentType)('json-patch', {
      resource: 'test',
      data: 'test'
    })).toBe('application/json-patch+json');
  });
  it('returns "multipart/form-data" for a specific resource that expects it', () => {
    expect((0, _requestContentType.requestContentType)('create', {
      resource: 'fileResources',
      data: 'test'
    })).toBe('multipart/form-data');
  });
  it('returns "text/plain" for a specific resource that expects it', () => {
    expect((0, _requestContentType.requestContentType)('create', {
      resource: 'messageConversations/feedback',
      data: 'test'
    })).toBe('text/plain');
  });
});
describe('requestHeadersForContentType', () => {
  it('returns undefined if contentType is null', () => {
    expect((0, _requestContentType.requestHeadersForContentType)(null)).toBe(undefined);
  });
  it('returns undefined if contentType is "multipart/form-data"', () => {
    expect((0, _requestContentType.requestHeadersForContentType)('multipart/form-data')).toBe(undefined);
  });
  it('returns a headers object with the contentType for "application/json"', () => {
    expect((0, _requestContentType.requestHeadersForContentType)('application/json')).toEqual({
      'Content-Type': 'application/json'
    });
  });
  it('returns a headers object with the contentType for "text/plain"', () => {
    expect((0, _requestContentType.requestHeadersForContentType)('text/plain')).toEqual({
      'Content-Type': 'text/plain'
    });
  });
});
describe('requestBodyForContentType', () => {
  it('returns undefined if data is undefined', () => {
    expect((0, _requestContentType.requestBodyForContentType)('application/json', {
      resource: 'test'
    })).toBe(undefined);
  });
  it('JSON stringifies the data if contentType is "application/json"', () => {
    const dataIn = {
      a: 'AAAA',
      b: 1,
      c: true
    };
    const dataOut = JSON.stringify(dataIn);
    expect((0, _requestContentType.requestBodyForContentType)('application/json', {
      resource: 'test',
      data: dataIn
    })).toBe(dataOut);
  });
  it('converts to FormData if contentType is "multipart/form-data"', () => {
    const file = new File(['foo'], 'foo.txt', {
      type: 'text/plain'
    });
    const data = {
      a: 'AAA',
      file
    };
    const result = (0, _requestContentType.requestBodyForContentType)('multipart/form-data', {
      resource: 'test',
      data
    });
    expect(result instanceof FormData).toBe(true);
    expect(result.get('a')).toBe('AAA');
    expect(result.get('file')).toBe(file);
  });
  it('throws an error if contentType is "multipart/form-data" and data does have own string-keyd properties', () => {
    expect(() => {
      (0, _requestContentType.requestBodyForContentType)('multipart/form-data', {
        resource: 'test',
        data: new File(['foo'], 'foo.txt', {
          type: 'text/plain'
        })
      });
    }).toThrowErrorMatchingInlineSnapshot(`"Could not convert data to FormData: object does not have own enumerable string-keyed properties"`);
  });
  it('converts to URLSearchParams if contentType is "application/x-www-form-urlencoded"', () => {
    const data = {
      a: 'AAA'
    };
    const result = (0, _requestContentType.requestBodyForContentType)('application/x-www-form-urlencoded', {
      resource: 'test',
      data
    });
    expect(result instanceof URLSearchParams).toBe(true);
    expect(result.get('a')).toBe('AAA');
  });
  it('throws an error if contentType is "application/x-www-form-urlencoded" and data does have own string-keyd properties', () => {
    expect(() => {
      (0, _requestContentType.requestBodyForContentType)('application/x-www-form-urlencoded', {
        resource: 'test',
        data: new File(['foo'], 'foo.txt', {
          type: 'text/plain'
        })
      });
    }).toThrowErrorMatchingInlineSnapshot(`"Could not convert data to URLSearchParams: object does not have own enumerable string-keyed properties"`);
  });
  it('returns the data as received if contentType is "text/plain"', () => {
    const data = 'Something';
    expect((0, _requestContentType.requestBodyForContentType)('text/plain', {
      resource: 'messageConversations/feedback',
      data
    })).toBe(data);
  });
});