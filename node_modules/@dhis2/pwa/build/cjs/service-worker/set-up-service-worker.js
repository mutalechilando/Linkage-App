"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setUpServiceWorker = setUpServiceWorker;

var _workboxPrecaching = require("workbox-precaching");

var _workboxRouting = require("workbox-routing");

var _workboxStrategies = require("workbox-strategies");

var _constants = require("../lib/constants.js");

var _dhis2ConnectionStatus = require("./dhis2-connection-status");

var _recordingMode = require("./recording-mode.js");

var _utils = require("./utils.js");

function setUpServiceWorker() {
  const pwaEnabled = process.env.REACT_APP_DHIS2_APP_PWA_ENABLED === 'true';

  if (!pwaEnabled) {
    // Install 'killswitch' service worker and refresh page to clear
    // rogue service workers. App should then unregister SW
    (0, _utils.setUpKillSwitchServiceWorker)();
    return;
  } // Misc setup
  // Disable verbose logs
  // TODO: control with env var


  self.__WB_DISABLE_DEV_LOGS = true; // Globals (Note: global state resets each time SW goes idle)

  (0, _recordingMode.initClientRecordingStates)();
  (0, _dhis2ConnectionStatus.initDhis2ConnectionStatus)(); // Local constants

  const PRODUCTION_ENV = process.env.NODE_ENV === 'production';
  const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$'); // Workbox routes
  // Only precache in production mode to enable easier app development.
  // In development, static assets are handled by 'network first' strategy
  // and will be kept up-to-date.

  if (PRODUCTION_ENV) {
    // Precache all of the assets generated by your build process.
    // Their URLs are injected into the manifest variable below.
    // This variable must be present somewhere in your service worker file,
    // even if you decide not to use precaching. See https://cra.link/PWA.
    // Includes all built assets and index.html
    const precacheManifest = self.__WB_MANIFEST || []; // todo: also do this routing for plugin.html
    // Extract index.html from the manifest to precache, then route
    // in a custom way

    const indexHtmlManifestEntry = precacheManifest.find(_ref => {
      let {
        url
      } = _ref;
      return url.endsWith('index.html');
    });
    (0, _workboxPrecaching.precache)([indexHtmlManifestEntry]); // Custom strategy for handling app navigation, specifically to allow
    // navigations to redirect to the login page while online if the
    // user is unauthenticated. Fixes showing the app shell login dialog
    // in production if a user is online and unauthenticated.
    // Uses app-shell style routing to route navigations to index.html.

    const navigationRouteMatcher = _ref2 => {
      let {
        request,
        url
      } = _ref2;

      // If this isn't a navigation, skip.
      if (request.mode !== 'navigate') {
        return false;
      } // If this is a URL that starts with /_, skip.


      if (url.pathname.startsWith('/_')) {
        return false;
      } // If this looks like a URL for a resource, because it contains
      // a file extension, skip (unless it's index.html)


      if (fileExtensionRegexp.test(url.pathname) && !url.pathname.endsWith('index.html')) {
        return false;
      } // Return true to signal that we want to use the handler.


      return true;
    };

    const indexUrl = process.env.PUBLIC_URL + '/index.html';

    const navigationRouteHandler = _ref3 => {
      let {
        request
      } = _ref3;
      return fetch(request).then(response => {
        if (response.type === 'opaqueredirect' || !response.ok) {
          // It's sending a redirect to the login page,
          // or an 'unauthorized'/'forbidden' response.
          // Return that to the client
          return response;
        } // Otherwise return precached index.html


        return (0, _workboxPrecaching.matchPrecache)(indexUrl);
      }).catch(() => {
        // Request failed (probably offline). Return cached response
        return (0, _workboxPrecaching.matchPrecache)(indexUrl);
      });
    }; // NOTE: This route must come before any precacheAndRoute calls


    (0, _workboxRouting.registerRoute)(navigationRouteMatcher, navigationRouteHandler); // Handle the rest of files in the manifest - filter out index.html,
    // and all moment-locales, which bulk up the precache and slow down
    // installation significantly. Handle them network-first in app shell

    const restOfManifest = precacheManifest.filter(e => {
      if (e === indexHtmlManifestEntry) {
        return false;
      } // Files from the precache manifest generated by CRA need to be
      // managed here, because we don't have access to their webpack
      // config


      const entryShouldBeExcluded = _utils.CRA_MANIFEST_EXCLUDE_PATTERNS.some(pattern => pattern.test(e.url));

      return !entryShouldBeExcluded;
    });
    (0, _workboxPrecaching.precacheAndRoute)(restOfManifest); // Same thing for built plugin assets

    const pluginPrecacheManifest = self.__WB_PLUGIN_MANIFEST || [];
    (0, _workboxPrecaching.precacheAndRoute)(pluginPrecacheManifest); // Similar to above; manifest injection from `workbox-build`
    // Precaches all assets in the shell's build folder except in `static`
    // (which CRA's workbox-webpack-plugin handle smartly).
    // Additional files to precache can be added using the
    // `additionalManifestEntries` option in d2.config.js; see the docs and
    // 'injectPrecacheManifest.js' in the CLI package.
    // '[]' fallback prevents an error when switching pwa enabled to disabled

    const sharedBuildManifest = self.__WB_BUILD_MANIFEST || [];
    (0, _workboxPrecaching.precacheAndRoute)(sharedBuildManifest);
  } // Handling pings: only use the network, and don't update the connection
  // status (let the runtime do that)
  // Two endpoints: /api(/version)/system/ping and /api/ping


  (0, _workboxRouting.registerRoute)(_ref4 => {
    let {
      url
    } = _ref4;
    return /\/api(\/\d+)?(\/system)?\/ping/.test(url.pathname);
  }, new _workboxStrategies.NetworkOnly()); // Request handler during recording mode: ALL requests are cached
  // Handling routing: https://developers.google.com/web/tools/workbox/modules/workbox-routing#matching_and_handling_in_routes

  (0, _workboxRouting.registerRoute)(_recordingMode.shouldRequestBeRecorded, new _recordingMode.RecordingMode({
    plugins: [_dhis2ConnectionStatus.dhis2ConnectionStatusPlugin]
  })); // If not recording, fall through to default caching strategies for app
  // shell:
  // SWR strategy for image assets that can't be precached.
  // (Skip in development environments)

  (0, _workboxRouting.registerRoute)(_ref5 => {
    let {
      url
    } = _ref5;
    return PRODUCTION_ENV && (0, _utils.urlMeetsAppShellCachingCriteria)(url) && /\.(jpg|gif|png|bmp|tiff|ico|woff)$/.test(url.pathname);
  }, new _workboxStrategies.StaleWhileRevalidate({
    cacheName: 'other-assets',
    plugins: [_dhis2ConnectionStatus.dhis2ConnectionStatusPlugin]
  })); // Network-first caching by default
  // * NOTE: there may be lazy-loading errors while offline in dev mode

  (0, _workboxRouting.registerRoute)(_ref6 => {
    let {
      url
    } = _ref6;
    return (0, _utils.urlMeetsAppShellCachingCriteria)(url);
  }, new _workboxStrategies.NetworkFirst({
    cacheName: 'app-shell',
    plugins: [_dhis2ConnectionStatus.dhis2ConnectionStatusPlugin]
  })); // Strategy for all other requests: try cache if network fails,
  // but don't add anything to cache

  class NetworkAndTryCache extends _workboxStrategies.Strategy {
    _handle(request, handler) {
      return handler.fetch(request).catch(fetchErr => {
        // handler.cacheMatch doesn't work b/c it doesn't check all caches
        return caches.match(request).then(res => {
          // If not found in cache, throw original fetchErr
          // (if there's a cache err, that will be returned)
          if (!res) {
            throw fetchErr;
          }

          return res;
        });
      });
    }

  } // Use fallback strategy as default


  (0, _workboxRouting.setDefaultHandler)(new NetworkAndTryCache({
    plugins: [_dhis2ConnectionStatus.dhis2ConnectionStatusPlugin]
  })); // Service Worker event handlers

  self.addEventListener('message', event => {
    if (!event.data) {
      return;
    }

    if (event.data.type === _constants.swMsgs.getClientsInfo) {
      (0, _utils.getClientsInfo)(event);
    } // Can be used upon first SW activation


    if (event.data.type === _constants.swMsgs.claimClients) {
      (0, _utils.claimClients)();
    } // This allows the web app to trigger skipWaiting via
    // registration.waiting.postMessage({type: 'SKIP_WAITING'})


    if (event.data.type === _constants.swMsgs.skipWaiting) {
      self.skipWaiting();
    } // Immediately trigger this throttled function -- this allows the app
    // to get the value ASAP upon startup, which it otherwise usually
    // has to wait for


    if (event.data.type === _constants.swMsgs.getImmediateDhis2ConnectionStatusUpdate) {
      _dhis2ConnectionStatus.broadcastDhis2ConnectionStatus.flush();
    }

    if (event.data.type === _constants.swMsgs.startRecording) {
      (0, _recordingMode.startRecording)(event);
    }

    if (event.data.type === _constants.swMsgs.completeRecording) {
      (0, _recordingMode.completeRecording)(event.source.id); // same as FetchEvent.clientId
    }
  }); // Open DB on activation

  self.addEventListener('activate', event => {
    event.waitUntil((0, _utils.createDB)().then(_utils.removeUnusedCaches));
  });
}