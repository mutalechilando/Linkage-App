import { Temporal } from '@js-temporal/polyfill';
import { formatYyyyMmDD, isCustomCalendar } from '../utils/helpers';
import localisationHelpers from '../utils/localisationHelpers';
import { monthNumbers } from './getMonthlyPeriods';
export const getYearlyPeriods = _ref => {
  let {
    year,
    calendar,
    periodType,
    yearsCount = 10,
    locale
  } = _ref;
  const month = getMonth(periodType);
  const currentYear = Temporal.PlainDate.from({
    year,
    month,
    day: calendar.toString() === 'nepali' ? 14 : 1,
    calendar
  });
  const years = [];
  for (let i = 0; i < yearsCount; i++) {
    const dateToAdd = currentYear.subtract({
      years: i
    });
    const value = buildValue({
      periodType,
      year: dateToAdd.year,
      month
    });
    const year = {
      id: value,
      iso: value,
      name: buildLabel(periodType, dateToAdd, {
        locale: locale || 'en',
        calendar
      }),
      ...buildStartAndEndDates(dateToAdd)
    };
    if (isFinancialYear(periodType)) {
      delete year.iso;
    }
    years.push(year);
  }
  return years;
};
const buildStartAndEndDates = date => {
  const endDate = Temporal.PlainDate.from({
    year: date.year + 1,
    month: date.month,
    day: 1,
    calendar: date.calendar
  }).subtract({
    days: 1
  });
  return {
    startDate: formatYyyyMmDD(date, 'startOfMonth'),
    endDate: formatYyyyMmDD(endDate, 'endOfMonth')
  };
};
const getMonth = periodType => {
  const yearType = periodType.replace('FY', '').toUpperCase();
  const monthInfo = monthNumbers[yearType];
  return (monthInfo === null || monthInfo === void 0 ? void 0 : monthInfo.value) || 1;
};
const buildLabel = (periodType, currentYearDate, options) => {
  if (periodType === 'YEARLY') {
    return currentYearDate.year.toString();
  }
  if (isCustomCalendar(options.calendar)) {
    return buildLabelForCustomCalendar(currentYearDate, options);
  }
  const format = {
    month: 'long',
    year: 'numeric',
    calendar: options.calendar
  };
  const fromYear = localisationHelpers.localiseMonth(currentYearDate, options, format);
  const toYear = localisationHelpers.localiseMonth(currentYearDate.add({
    months: currentYearDate.monthsInYear - 1
  }), options, format);
  let result = `${fromYear} - ${toYear}`;

  // needed for Ethiopic calendar
  result = result.replace(/ERA\d+\s*/g, '').trim();
  return result;
};
const buildLabelForCustomCalendar = (date, options) => {
  const localiseMonth = dateToDisplay => `${localisationHelpers.localiseMonth(dateToDisplay, options, {})} ${dateToDisplay.year}`;
  const nextYearDate = Temporal.PlainDate.from({
    year: date.year + 1,
    month: date.month - 1,
    day: 1,
    calendar: options.calendar
  });
  const result = `${localiseMonth(date)} - ${localiseMonth(nextYearDate)}`;
  return result;
};
const monthValueKeys = {
  1: '',
  2: 'Feb',
  3: 'March',
  // some keys are full month-names, some are short ... for some reason
  4: 'April',
  5: 'May',
  6: 'Jun',
  7: 'July',
  8: 'Aug',
  9: 'Sep',
  10: 'Oct',
  11: 'Nov',
  12: 'Dec'
};
const buildValue = _ref2 => {
  let {
    periodType,
    year,
    month
  } = _ref2;
  if (periodType === 'YEARLY') {
    return year.toString();
  }
  // financial year
  if (isFinancialYear(periodType)) {
    const yearType = monthValueKeys[month];
    return `${year}${yearType}`;
  }
  throw new Error(`can not build value for unrecognised yearly type "${periodType}"`);
};
const isFinancialYear = periodType => {
  return periodType.startsWith('FY');
};