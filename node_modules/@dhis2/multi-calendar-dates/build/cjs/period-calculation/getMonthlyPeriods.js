"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.monthNumbers = exports.getMonthlyPeriods = void 0;
var _polyfill = require("@js-temporal/polyfill");
var _helpers = require("../utils/helpers");
var _localisationHelpers = _interopRequireDefault(require("../utils/localisationHelpers"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const getMonthlyPeriods = _ref => {
  let {
    year,
    calendar,
    periodType,
    locale = 'en'
  } = _ref;
  let currentMonth = _polyfill.Temporal.PlainDate.from({
    year,
    month: getStartingMonth(periodType),
    day: calendar.toString() === 'nepali' ? 14 : 1,
    calendar
  });
  const months = [];
  const monthToAdd = getMonthsToAdd(periodType);
  let index = 1;
  while (currentMonth.year === year || needsExtraMonth(periodType, months.length)) {
    const nextMonth = currentMonth.add({
      months: monthToAdd
    });
    if (!ignoreMonth(calendar, currentMonth)) {
      const id = buildValue({
        periodType,
        currentMonth,
        year,
        index
      });
      months.push({
        id,
        iso: id,
        name: buildLabel({
          periodType,
          month: currentMonth,
          locale,
          calendar,
          nextMonth: nextMonth.subtract({
            months: 1
          }),
          // when we display, we want to show the range using previous month
          index
        }),
        ...buildStartAndEndDate(currentMonth, nextMonth)
      });
    }
    currentMonth = _polyfill.Temporal.PlainDate.from(nextMonth);
    index++;
  }
  return months;
};
exports.getMonthlyPeriods = getMonthlyPeriods;
/**
 * special cases where we ignore a month
 */
const ignoreMonth = (calendar, date) => {
  // in Ethiopic calendar, for periods more than bi-weekly, we ignore the 13th month
  if (calendar === 'ethiopic' && date.month === 13) {
    return true;
  }
  return false;
};
const buildValue = _ref2 => {
  let {
    periodType,
    currentMonth,
    year,
    index
  } = _ref2;
  if (periodType === 'BIMONTHLY') {
    return `${year}${(0, _helpers.padWithZeroes)(index)}B`;
  }
  if (periodType === 'QUARTERLY') {
    return `${year}Q${index}`;
  }
  if (periodType === 'SIXMONTHLY') {
    return `${year}S${index}`;
  }
  if (periodType.match(/QUARTERLY/)) {
    var _getMonthInfo;
    const month = (_getMonthInfo = getMonthInfo(periodType)) === null || _getMonthInfo === void 0 ? void 0 : _getMonthInfo.name;
    return `${year}${month}Q${index}`;
  }
  if (periodType.match(/SIXMONTHLY/)) {
    var _getMonthInfo2;
    const month = (_getMonthInfo2 = getMonthInfo(periodType)) === null || _getMonthInfo2 === void 0 ? void 0 : _getMonthInfo2.name;
    return `${year}${month}S${index}`;
  }
  return `${year}${(0, _helpers.padWithZeroes)(currentMonth.month)}`;
};
const buildLabel = options => {
  const {
    periodType,
    month,
    nextMonth,
    calendar,
    locale
  } = options;
  if ((0, _helpers.isCustomCalendar)(calendar)) {
    return buildLabelForCustomCalendar(options);
  }
  const withYearFormat = {
    month: 'long',
    year: 'numeric',
    calendar
  };
  const monthOnlyFormat = {
    month: 'long',
    calendar
  };
  let result = '';
  if (['BIMONTHLY', 'QUARTERLY', 'SIXMONTHLY'].includes(periodType) || periodType.match(/SIXMONTHLY|QUARTERLY/)) {
    const format = month.year === nextMonth.year ? monthOnlyFormat : withYearFormat;
    result = `${(0, _helpers.capitalize)(month.toLocaleString(locale, format), locale)} - ${(0, _helpers.capitalize)(nextMonth.toLocaleString(locale, withYearFormat), locale)}`;
  } else {
    result = `${(0, _helpers.capitalize)(month.toLocaleString(locale, withYearFormat), locale)}`;
  }

  // needed for ethiopic calendar - the default formatter adds the era, which is not what we want in DHIS2
  result = result.replace(/ERA\d+\s*/g, '').trim();
  return result;
};
const buildLabelForCustomCalendar = _ref3 => {
  let {
    periodType,
    month,
    nextMonth,
    calendar,
    locale
  } = _ref3;
  let result = '';
  if (['BIMONTHLY', 'QUARTERLY', 'SIXMONTHLY'].includes(periodType) || periodType.match(/SIXMONTHLY|QUARTERLY/)) {
    const showYear = month.year !== nextMonth.year;
    result = `${_localisationHelpers.default.localiseMonth(month, {
      locale,
      calendar
    }, {})}${showYear ? ` ${month.year}` : ''} - ${_localisationHelpers.default.localiseMonth(nextMonth, {
      locale,
      calendar
    }, {})} ${nextMonth.year}`;
  } else {
    result = `${_localisationHelpers.default.localiseMonth(month, {
      locale,
      calendar
    }, {})} ${nextMonth.year}`;
  }
  return result;
};
const getMonthsToAdd = periodType => {
  if (periodType !== null && periodType !== void 0 && periodType.match(/SIXMONTHLY/)) {
    return 6;
  }
  if (periodType !== null && periodType !== void 0 && periodType.match(/QUARTERLY/)) {
    return 3;
  }
  if (periodType === 'MONTHLY') {
    return 1;
  }
  if (periodType === 'BIMONTHLY') {
    return 2;
  }
  throw new Error(`unrecognised monthly period type ${periodType}`);
};
const monthNumbers = {
  JAN: {
    value: 1,
    name: 'January'
  },
  FEB: {
    value: 2,
    name: 'February'
  },
  MAR: {
    value: 3,
    name: 'March'
  },
  APR: {
    value: 4,
    name: 'April'
  },
  MAY: {
    value: 5,
    name: 'May'
  },
  JUN: {
    value: 6,
    name: 'June'
  },
  JUL: {
    value: 7,
    name: 'July'
  },
  AUG: {
    value: 8,
    name: 'August'
  },
  SEP: {
    value: 9,
    name: 'September'
  },
  OCT: {
    value: 10,
    name: 'October'
  },
  NOV: {
    value: 11,
    name: 'November'
  },
  DEC: {
    value: 12,
    name: 'December'
  }
};
exports.monthNumbers = monthNumbers;
const getMonthInfo = periodType => {
  const monthString = periodType.replace('SIXMONTHLY', '').replace('QUARTERLY', '');
  return monthNumbers[monthString];
};
const getStartingMonth = periodType => {
  if (periodType.match(/SIXMONTHLY|QUARTERLY/)) {
    if (periodType === 'SIXMONTHLY' || periodType === 'QUARTERLY') {
      return 1;
    } else {
      var _getMonthInfo$value, _getMonthInfo3;
      return (_getMonthInfo$value = (_getMonthInfo3 = getMonthInfo(periodType)) === null || _getMonthInfo3 === void 0 ? void 0 : _getMonthInfo3.value) !== null && _getMonthInfo$value !== void 0 ? _getMonthInfo$value : 1;
    }
  } else {
    return 1;
  }
};
function needsExtraMonth(periodType, length) {
  if (periodType.match(/SIXMONTHLY/)) {
    return length < 2;
  }
  if (periodType.match(/QUARTERLY/)) {
    return length < 4;
  }
  return false;
}
const buildStartAndEndDate = (currentMonth, nextMonth) => {
  if (currentMonth.calendar === 'ethiopic') {
    console.warn('todo: confirm the special cases for the 13th month with Abyot, then update the start/end dates for Ethiopic calendar');
  }
  const endDate = _polyfill.Temporal.PlainDate.from({
    year: nextMonth.year,
    month: nextMonth.month,
    day: 1,
    calendar: nextMonth.calendar
  }).subtract({
    days: 1
  });
  return {
    startDate: (0, _helpers.formatYyyyMmDD)(currentMonth, 'startOfMonth'),
    endDate: (0, _helpers.formatYyyyMmDD)(endDate, 'endOfMonth')
  };
};