"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getYearlyPeriods = void 0;
var _polyfill = require("@js-temporal/polyfill");
var _helpers = require("../utils/helpers");
var _localisationHelpers = _interopRequireDefault(require("../utils/localisationHelpers"));
var _getMonthlyPeriods = require("./getMonthlyPeriods");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const getYearlyPeriods = _ref => {
  let {
    year,
    calendar,
    periodType,
    yearsCount = 10,
    locale
  } = _ref;
  const month = getMonth(periodType);
  const currentYear = _polyfill.Temporal.PlainDate.from({
    year,
    month,
    day: calendar.toString() === 'nepali' ? 14 : 1,
    calendar
  });
  const years = [];
  for (let i = 0; i < yearsCount; i++) {
    const dateToAdd = currentYear.subtract({
      years: i
    });
    const value = buildValue({
      periodType,
      year: dateToAdd.year,
      month
    });
    const year = {
      id: value,
      iso: value,
      name: buildLabel(periodType, dateToAdd, {
        locale: locale || 'en',
        calendar
      }),
      ...buildStartAndEndDates(dateToAdd)
    };
    if (isFinancialYear(periodType)) {
      delete year.iso;
    }
    years.push(year);
  }
  return years;
};
exports.getYearlyPeriods = getYearlyPeriods;
const buildStartAndEndDates = date => {
  const endDate = _polyfill.Temporal.PlainDate.from({
    year: date.year + 1,
    month: date.month,
    day: 1,
    calendar: date.calendar
  }).subtract({
    days: 1
  });
  return {
    startDate: (0, _helpers.formatYyyyMmDD)(date, 'startOfMonth'),
    endDate: (0, _helpers.formatYyyyMmDD)(endDate, 'endOfMonth')
  };
};
const getMonth = periodType => {
  const yearType = periodType.replace('FY', '').toUpperCase();
  const monthInfo = _getMonthlyPeriods.monthNumbers[yearType];
  return (monthInfo === null || monthInfo === void 0 ? void 0 : monthInfo.value) || 1;
};
const buildLabel = (periodType, currentYearDate, options) => {
  if (periodType === 'YEARLY') {
    return currentYearDate.year.toString();
  }
  if ((0, _helpers.isCustomCalendar)(options.calendar)) {
    return buildLabelForCustomCalendar(currentYearDate, options);
  }
  const format = {
    month: 'long',
    year: 'numeric',
    calendar: options.calendar
  };
  const fromYear = _localisationHelpers.default.localiseMonth(currentYearDate, options, format);
  const toYear = _localisationHelpers.default.localiseMonth(currentYearDate.add({
    months: currentYearDate.monthsInYear - 1
  }), options, format);
  let result = `${fromYear} - ${toYear}`;

  // needed for Ethiopic calendar
  result = result.replace(/ERA\d+\s*/g, '').trim();
  return result;
};
const buildLabelForCustomCalendar = (date, options) => {
  const localiseMonth = dateToDisplay => `${_localisationHelpers.default.localiseMonth(dateToDisplay, options, {})} ${dateToDisplay.year}`;
  const nextYearDate = _polyfill.Temporal.PlainDate.from({
    year: date.year + 1,
    month: date.month - 1,
    day: 1,
    calendar: options.calendar
  });
  const result = `${localiseMonth(date)} - ${localiseMonth(nextYearDate)}`;
  return result;
};
const monthValueKeys = {
  1: '',
  2: 'Feb',
  3: 'March',
  // some keys are full month-names, some are short ... for some reason
  4: 'April',
  5: 'May',
  6: 'Jun',
  7: 'July',
  8: 'Aug',
  9: 'Sep',
  10: 'Oct',
  11: 'Nov',
  12: 'Dec'
};
const buildValue = _ref2 => {
  let {
    periodType,
    year,
    month
  } = _ref2;
  if (periodType === 'YEARLY') {
    return year.toString();
  }
  // financial year
  if (isFinancialYear(periodType)) {
    const yearType = monthValueKeys[month];
    return `${year}${yearType}`;
  }
  throw new Error(`can not build value for unrecognised yearly type "${periodType}"`);
};
const isFinancialYear = periodType => {
  return periodType.startsWith('FY');
};