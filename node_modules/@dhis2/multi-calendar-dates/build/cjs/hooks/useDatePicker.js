"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDatePicker = void 0;
var _polyfill = require("@js-temporal/polyfill");
var _react = require("react");
var _dhis2CalendarsMap2 = require("../constants/dhis2CalendarsMap");
var _index = require("../index");
var _helpers = require("../utils/helpers");
var _localisationHelpers = _interopRequireDefault(require("../utils/localisationHelpers"));
var _useCalendarWeekDays = require("./internal/useCalendarWeekDays");
var _useNavigation = require("./internal/useNavigation");
var _useResolvedLocaleOptions = require("./internal/useResolvedLocaleOptions");
var _useWeekDayLabels = require("./internal/useWeekDayLabels");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const fromDateParts = (date, options) => {
  let result;
  try {
    const dateParts = date === null || date === void 0 ? void 0 : date.split('-');
    if (dateParts.length !== 3) {
      throw new Error(`Invalid date ${date} - date should be in the format YYYY-MM-DD`);
    }
    const [year, month, day] = dateParts;
    result = {
      year: Number(year),
      month: Number(month),
      day: Number(day)
    };
  } catch (err) {
    console.warn(err);
    const {
      year,
      month,
      day
    } = (0, _index.getNowInCalendar)(options.calendar, options.timeZone);
    result = {
      year,
      month,
      day
    };
  }

  // for ethiopic, we need to make sure it's the correct era
  // there is a discussion in the Temporal proposal whether this
  // should be made the default era, for now this is a workaround
  if (options.calendar === 'ethiopic') {
    result.era = 'era1';
    result.eraYear = result.year;
    delete result.year;
  }
  return result;
};
const useDatePicker = _ref => {
  var _dhis2CalendarsMap;
  let {
    onDateSelect,
    date: dateParts,
    options
  } = _ref;
  const calendar = (0, _helpers.getCustomCalendarIfExists)((_dhis2CalendarsMap = _dhis2CalendarsMap2.dhis2CalendarsMap[options.calendar]) !== null && _dhis2CalendarsMap !== void 0 ? _dhis2CalendarsMap : options.calendar);
  const resolvedOptions = (0, _useResolvedLocaleOptions.useResolvedLocaleOptions)({
    ...options,
    calendar
  });
  const prevDateStringRef = (0, _react.useRef)(dateParts);
  const todayZdt = (0, _react.useMemo)(() => (0, _index.getNowInCalendar)(resolvedOptions.calendar, resolvedOptions.timeZone).startOfDay(), [resolvedOptions]);
  const date = dateParts ? fromDateParts(dateParts, resolvedOptions) : todayZdt;
  const temporalCalendar = (0, _react.useMemo)(() => _polyfill.Temporal.Calendar.from(resolvedOptions.calendar), [resolvedOptions.calendar]);
  const temporalTimeZone = (0, _react.useMemo)(() => _polyfill.Temporal.TimeZone.from(resolvedOptions.timeZone), [resolvedOptions]);
  const selectedDateZdt = (0, _react.useMemo)(() => date ? _polyfill.Temporal.Calendar.from(temporalCalendar).dateFromFields(date).toZonedDateTime({
    timeZone: temporalTimeZone
  }) : null, [date, temporalTimeZone, temporalCalendar]);
  const [firstZdtOfVisibleMonth, setFirstZdtOfVisibleMonth] = (0, _react.useState)(() => {
    const zdt = selectedDateZdt || todayZdt;
    return zdt.with({
      day: 1
    });
  });
  const localeOptions = (0, _react.useMemo)(() => ({
    locale: resolvedOptions.locale,
    calendar: temporalCalendar,
    timeZone: temporalTimeZone,
    weekDayFormat: resolvedOptions.weekDayFormat,
    numberingSystem: resolvedOptions.numberingSystem
  }), [resolvedOptions, temporalCalendar, temporalTimeZone]);
  const weekDayLabels = (0, _useWeekDayLabels.useWeekDayLabels)(localeOptions);
  const navigation = (0, _useNavigation.useNavigation)(firstZdtOfVisibleMonth.withCalendar(localeOptions.calendar), setFirstZdtOfVisibleMonth, localeOptions);
  const selectDate = (0, _react.useCallback)(zdt => {
    onDateSelect({
      calendarDate: zdt,
      calendarDateString: (0, _helpers.formatYyyyMmDD)(zdt)
    });
  }, [onDateSelect]);
  const calendarWeekDaysZdts = (0, _useCalendarWeekDays.useCalendarWeekDays)(firstZdtOfVisibleMonth);
  (0, _react.useEffect)(() => {
    if (dateParts === prevDateStringRef.current) {
      return;
    }
    prevDateStringRef.current = dateParts;
    if (!dateParts) {
      return;
    }
    const zdt = _polyfill.Temporal.Calendar.from(temporalCalendar).dateFromFields(date).toZonedDateTime({
      timeZone: temporalTimeZone
    });
    if ((firstZdtOfVisibleMonth.year !== zdt.year || firstZdtOfVisibleMonth.month !== zdt.month) && !calendarWeekDaysZdts.some(week => week.some(day => day.equals(zdt)))) {
      setFirstZdtOfVisibleMonth(zdt.subtract({
        days: zdt.day - 1
      }));
    }
  }, [date, dateParts, firstZdtOfVisibleMonth, calendarWeekDaysZdts, temporalCalendar, temporalTimeZone]);
  return {
    calendarWeekDays: calendarWeekDaysZdts.map(week => week.map(weekDayZdt => ({
      zdt: weekDayZdt,
      calendarDate: (0, _helpers.formatYyyyMmDD)(weekDayZdt),
      label: _localisationHelpers.default.localiseWeekLabel(weekDayZdt.withCalendar(localeOptions.calendar), localeOptions),
      onClick: () => selectDate(weekDayZdt),
      isSelected: selectedDateZdt === null || selectedDateZdt === void 0 ? void 0 : selectedDateZdt.withCalendar('iso8601').equals(weekDayZdt.withCalendar('iso8601')),
      isToday: todayZdt && weekDayZdt.equals(todayZdt),
      isInCurrentMonth: firstZdtOfVisibleMonth && weekDayZdt.month === firstZdtOfVisibleMonth.month
    }))),
    ...navigation,
    weekDayLabels
  };
};
exports.useDatePicker = useDatePicker;