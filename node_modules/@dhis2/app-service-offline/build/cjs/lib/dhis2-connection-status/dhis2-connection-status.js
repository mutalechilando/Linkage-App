"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDhis2ConnectionStatus = exports.getLastConnectedKey = exports.Dhis2ConnectionStatusProvider = void 0;

var _appServiceConfig = require("@dhis2/app-service-config");

var _lodash = require("lodash");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _offlineInterface = require("../offline-interface");

var _devDebugLog = require("./dev-debug-log");

var _isPingAvailable = require("./is-ping-available");

var _smartInterval = _interopRequireDefault(require("./smart-interval"));

var _usePingQuery = require("./use-ping-query");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Utils for saving 'last connected' datetime in local storage
const lastConnectedKey = 'dhis2.lastConnected';

const getLastConnectedKey = appName => appName ? `${lastConnectedKey}.${appName}` : lastConnectedKey;

exports.getLastConnectedKey = getLastConnectedKey;

const updateLastConnected = appName => {
  // use Date.now() because it's easier to mock for easier unit testing
  const now = new Date(Date.now());
  localStorage.setItem(getLastConnectedKey(appName), now.toUTCString());
  return now;
};

const getLastConnected = appName => {
  const lastConnected = localStorage.getItem(getLastConnectedKey(appName));
  return lastConnected ? new Date(lastConnected) : null;
};

const clearLastConnected = appName => {
  localStorage.removeItem(getLastConnectedKey(appName));
};

const Dhis2ConnectionStatusContext = /*#__PURE__*/_react.default.createContext({
  isConnected: true,
  isDisconnected: false,
  lastConnected: null
});
/**
 * Provides a boolean indicating client's connection to the DHIS2 server,
 * which is different from connection to the internet.
 *
 * The context provider subscribes to messages from the SW tracking successes
 * and failures of requests to the DHIS2 server to determine connection status,
 * and then will initiate periodic pings if there are no incidental requests in
 * order to check the connection consistently
 */


const Dhis2ConnectionStatusProvider = (_ref) => {
  let {
    children
  } = _ref;
  const offlineInterface = (0, _offlineInterface.useOfflineInterface)();
  const {
    appName,
    serverVersion
  } = (0, _appServiceConfig.useConfig)(); // The offline interface persists the latest update from the SW so that
  // this hook can initialize to an accurate value. The App Adapter in the
  // platform waits for this value to be populated before rendering the
  // the App Runtime provider (including this), but if that is not done,
  // `latestIsConnected` may be `null` depending on the outcome of race
  // conditions between the SW and the React component tree.

  const [isConnected, setIsConnected] = (0, _react.useState)(offlineInterface.latestIsConnected);
  const ping = (0, _usePingQuery.usePingQuery)();
  const smartIntervalRef = (0, _react.useRef)(null);
  /**
   * Update state, reset ping backoff if changed, and update
   * the lastConnected value in localStorage
   */

  const updateConnectedState = (0, _react.useCallback)(newIsConnected => {
    // use 'set' with a function as param to get latest isConnected
    // without needing it as a dependency for useCallback
    setIsConnected(prevIsConnected => {
      (0, _devDebugLog.devDebugLog)('[D2CS] updating state:', {
        prevIsConnected,
        newIsConnected
      });

      if (newIsConnected !== prevIsConnected) {
        var _smartIntervalRef$cur;

        // if value changed, reset ping interval to initial delay
        (_smartIntervalRef$cur = smartIntervalRef.current) === null || _smartIntervalRef$cur === void 0 ? void 0 : _smartIntervalRef$cur.reset();

        if (newIsConnected) {
          // Need to clear this here so it doesn't affect another
          // session that starts while offline
          clearLastConnected(appName);
        } else {
          updateLastConnected(appName);
        }
      }

      return newIsConnected;
    });
  }, [appName]); // Note that the SW is configured to not cache ping requests and won't
  // trigger `handleChange` below to avoid redundant signals. This also
  // helps to detect the connectivity status when the SW is not available
  // for some reason (maybe private browsing, first installation, or
  // insecure browser context)

  const pingAndHandleStatus = (0, _react.useCallback)(() => {
    return ping().then(() => {
      // Ping is successful; set 'connected'
      updateConnectedState(true);
    }).catch(err => {
      console.error('Ping failed:', err.message);
      updateConnectedState(false);
    });
  }, [ping, updateConnectedState]);
  /** Called when SW reports updates from incidental network traffic */

  const onUpdate = (0, _react.useCallback)((_ref2) => {
    var _smartIntervalRef$cur2;

    let {
      isConnected: newIsConnected
    } = _ref2;
    (0, _devDebugLog.devDebugLog)('[D2CS] handling update from sw'); // Snooze ping timer to reduce pings since we know state from SW

    (_smartIntervalRef$cur2 = smartIntervalRef.current) === null || _smartIntervalRef$cur2 === void 0 ? void 0 : _smartIntervalRef$cur2.snooze();
    updateConnectedState(newIsConnected);
  }, [updateConnectedState]);
  (0, _react.useEffect)(() => {
    // If the /api/ping endpoint is not available on this instance, skip
    // pinging with the smart interval. Just use the service worker
    if (!serverVersion || !(0, _isPingAvailable.isPingAvailable)(serverVersion)) {
      return;
    } // Only create the smart interval once


    const smartInterval = (0, _smartInterval.default)({
      // don't ping if window isn't focused or visible
      initialPauseValue: !document.hasFocus() || document.visibilityState !== 'visible',
      callback: pingAndHandleStatus
    });
    smartIntervalRef.current = smartInterval;

    const handleBlur = () => smartInterval.pause();

    const handleFocus = () => smartInterval.resume(); // Pinging when going offline should be low/no-cost in both online and
    // local servers


    const handleOffline = () => smartInterval.invokeCallbackImmediately(); // Pinging when going online has a cost but improves responsiveness of
    // the connection status -- only do it once every 15 seconds at most


    const handleOnline = (0, _lodash.throttle)(() => smartInterval.invokeCallbackImmediately(), 15000);
    window.addEventListener('blur', handleBlur);
    window.addEventListener('focus', handleFocus);
    window.addEventListener('offline', handleOffline);
    window.addEventListener('online', handleOnline);
    return () => {
      window.removeEventListener('blur', handleBlur);
      window.removeEventListener('focus', handleFocus);
      window.removeEventListener('offline', handleOffline);
      window.removeEventListener('online', handleOnline); // clean up smart interval and throttled function

      smartInterval.clear();
      handleOnline.cancel();
    };
  }, [pingAndHandleStatus, serverVersion]);
  (0, _react.useEffect)(() => {
    const unsubscribe = offlineInterface.subscribeToDhis2ConnectionStatus({
      onUpdate
    });
    return () => {
      unsubscribe();
    };
  }, [offlineInterface, onUpdate]); // Memoize this value to prevent unnecessary rerenders of context provider

  const contextValue = (0, _react.useMemo)(() => ({
    // in the unlikely circumstance that offlineInterface.latestIsConnected
    // is `null` when this initializes, fail safe by defaulting to
    // `isConnected: false`
    isConnected: Boolean(isConnected),
    isDisconnected: !isConnected,
    lastConnected: isConnected ? null : // Only evaluate if disconnected, since local storage
    // is synchronous and disk-based.
    // If lastConnected is not set in localStorage though, set it.
    // (relevant on startup)
    getLastConnected(appName) || updateLastConnected(appName)
  }), [isConnected, appName]);
  return /*#__PURE__*/_react.default.createElement(Dhis2ConnectionStatusContext.Provider, {
    value: contextValue
  }, children);
};

exports.Dhis2ConnectionStatusProvider = Dhis2ConnectionStatusProvider;
Dhis2ConnectionStatusProvider.propTypes = {
  children: _propTypes.default.node
};

const useDhis2ConnectionStatus = () => {
  const context = (0, _react.useContext)(Dhis2ConnectionStatusContext);

  if (!context) {
    throw new Error('useDhis2ConnectionStatus must be used within a Dhis2ConnectionStatus provider');
  }

  return context;
};

exports.useDhis2ConnectionStatus = useDhis2ConnectionStatus;