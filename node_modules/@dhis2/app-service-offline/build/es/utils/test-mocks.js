export const successfulRecordingMock = jest.fn().mockImplementation(async function () {
  let {
    onStarted,
    onCompleted
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // in 100ms, call 'onStarted' callback (allows 'pending' state)
  if (onStarted) {
    setTimeout(onStarted, 100);
  } // in 200ms, call 'onCompleted' callback


  if (onCompleted) {
    setTimeout(onCompleted, 200);
  } // resolve


  return Promise.resolve();
});
export const errorRecordingMock = jest.fn().mockImplementation(function () {
  let {
    onStarted,
    onError
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // in 100ms, call 'onStarted' callback (allows 'pending' state)
  if (onStarted) {
    setTimeout(onStarted, 100);
  } // in 200ms, call 'onError'


  setTimeout(() => onError(new Error('test err')), 200); // resolve to signal successful initiation

  return Promise.resolve();
});
export const failedMessageRecordingMock = jest.fn().mockRejectedValue(new Error('Failed message'));
export const mockOfflineInterface = {
  pwaEnabled: true,
  latestIsConnected: true,
  startRecording: successfulRecordingMock,
  getCachedSections: jest.fn().mockResolvedValue([]),
  removeSection: jest.fn().mockResolvedValue(true),
  // returns an unsubscribe function
  subscribeToDhis2ConnectionStatus: jest.fn().mockReturnValue(() => undefined)
};